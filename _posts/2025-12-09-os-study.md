---
title: "내손으로 만들어보는 OS"
categories:
  - blog
tags:
  - os
  - kernel
---

## OS 개발 도메인 지식

- [ ] 부트로더와 부팅 프로세스 (BIOS/UEFI)
- [ ] 메모리 관리 (페이징, 세그멘테이션, 가상 메모리)
- [ ] 인터럽트와 예외 처리 메커니즘
- [ ] 프로세스와 스레드 관리
- [ ] 파일 시스템 기본 개념 (FAT, ext2 등)
- [ ] 하드웨어 추상화 계층 (HAL)
- [ ] 시스템 콜 인터페이스 설계
- [ ] 디바이스 드라이버 아키텍처
- [ ] 커널 동시성 및 동기화
- [ ] 보안 및 권한 관리 (링 보호, 사용자/커널 모드)

## 주요 실습 주제

- [ ] 1. 최소 부팅 가능한 커널 구현
  - [ ] `no_std` 환경 설정
  - [ ] 부트로더 통합 (`bootloader` 크레이트)
  - [ ] 기본 커널 진입점 구현
  - [ ] QEMU/Hyper-V에서 실행 확인

- [ ] 2. VGA 텍스트 모드 출력 구현
  - [ ] VGA 버퍼 직접 접근
  - [ ] 텍스트 출력 함수 구현
  - [ ] 색상 및 포맷팅 지원
  - [ ] 커서 관리

- [ ] 3. 인터럽트 처리 구현
  - [ ] IDT (Interrupt Descriptor Table) 설정
  - [ ] 예외 핸들러 구현
  - [ ] 하드웨어 인터럽트 처리
  - [ ] PIC (Programmable Interrupt Controller) 설정

- [ ] 4. 메모리 관리자 구현
  - [ ] 페이지 프레임 할당자
  - [ ] 힙 할당자 구현 (커스텀 allocator)
  - [ ] 가상 메모리 매핑
  - [ ] 메모리 보호 및 권한 관리

- [ ] 5. 프로세스 스케줄러 구현
  - [ ] 프로세스 구조체 설계
  - [ ] 컨텍스트 스위칭 구현
  - [ ] 스케줄링 알고리즘 (Round Robin, Priority 등)
  - [ ] 프로세스 상태 관리

- [ ] 6. 기본 파일 시스템 구현
  - [ ] 파일 시스템 드라이버 인터페이스
  - [ ] 간단한 파일 시스템 구현 (예: 초소형 FS)
  - [ ] 파일 읽기/쓰기 연산
  - [ ] 디렉토리 관리

- [ ] 7. 시스템 콜 인터페이스 구현
  - [ ] 시스템 콜 핸들러 설계
  - [ ] 사용자 모드/커널 모드 전환
  - [ ] 주요 시스템 콜 구현 (read, write, open, close 등)
  - [ ] 시스템 콜 번호 관리

- [ ] 8. 멀티태스킹 지원
  - [ ] 다중 프로세스 실행
  - [ ] 프로세스 간 통신 (IPC)
  - [ ] 시그널 처리
  - [ ] 프로세스 간 동기화

- [ ] 9. (옵션) 네트워크 스택 구현
  - [ ] 네트워크 드라이버 인터페이스
  - [ ] 이더넷 프레임 처리
  - [ ] IP 패킷 처리
  - [ ] TCP/UDP 프로토콜 구현 (기본)

- [ ] 10. (옵션) 드라이버 프레임워크 구현
  - [ ] 드라이버 인터페이스 설계
  - [ ] 디바이스 등록 및 관리
  - [ ] 키보드/마우스 드라이버
  - [ ] 타이머 드라이버

- [ ] 11. (옵션) 완전한 운영체제 프로토타입
  - [ ] 모든 모듈 통합
  - [ ] 사용자 프로그램 실행 환경
  - [ ] 기본 유틸리티 프로그램
  - [ ] 문서화 및 테스트

## 주요 학습 주제

### 1. `no_std` 환경과 커스텀 할당자

표준 라이브러리가 없는 환경에서 작업해야 합니다. 모든 기능을 직접 구현하거나 크레이트를 활용해야 합니다.

- `#![no_std]` 속성 이해
- `core`와 `alloc` 크레이트 활용
- 커스텀 글로벌 할당자 구현
- 힙 할당 없이 작업하기

### 2. `unsafe` 코드와 메모리 안전성

하드웨어 직접 제어와 저수준 작업에는 `unsafe`가 필요합니다. 안전한 추상화를 통해 `unsafe` 사용을 최소화해야 합니다.

- `unsafe` 블록의 올바른 사용
- 안전한 추상화 설계
- `unsafe` 코드 검증 전략
- 메모리 안전성 보장

### 3. 하드웨어 직접 제어

레지스터 직접 접근, 메모리 매핑 I/O 등 하드웨어와 직접 통신해야 합니다.

- MMIO (Memory-Mapped I/O)
- 포트 I/O
- `volatile` 접근 패턴
- 하드웨어 레지스터 타입 안전성

### 4. 인터럽트 컨텍스트 처리

인터럽트 핸들러는 특별한 제약이 있습니다. 블로킹 연산을 피하고 최소한의 작업만 수행해야 합니다.

- 인터럽트 컨텍스트의 제약사항
- 인터럽트 핸들러 설계 원칙
- 디퍼드 작업 처리
- 인터럽트 우선순위 관리

### 5. 커널 동시성 및 동기화

커널은 멀티코어 환경에서 동시에 실행될 수 있습니다. 락 프리 알고리즘과 적절한 동기화가 필수입니다.

- 스핀락과 뮤텍스
- 락 프리 데이터 구조
- 원자적 연산 활용
- 데드락 방지 전략

### 6. 크로스 컴파일과 링커 스크립트

타겟 아키텍처에 맞는 바이너리를 생성해야 합니다. 링커 스크립트로 메모리 레이아웃을 제어합니다.

- 크로스 컴파일 툴체인 설정
- 타겟 트리플 설정
- 링커 스크립트 작성
- 섹션 배치 및 정렬

### 7. 디버깅 및 테스트 전략

커널 디버깅은 일반 애플리케이션보다 어렵습니다. QEMU와 GDB를 활용한 원격 디버깅이 필수입니다.

- QEMU GDB 연동
- 시리얼 포트 로깅
- 커널 패닉 처리
- 단위 테스트 전략

## 핵심 라이브러리

- [`bootloader`](https://crates.io/crates/bootloader): 부트로더 통합 및 부팅 프로세스 관리
- [`x86_64`](https://crates.io/crates/x86_64): x86_64 아키텍처 특화 기능 (페이지 테이블, 인터럽트 등)
- [`volatile`](https://crates.io/crates/volatile): 하드웨어 레지스터 안전 접근
- [`spin`](https://crates.io/crates/spin): 스핀락 및 동기화 프리미티브
- [`uart_16550`](https://crates.io/crates/uart_16550): 시리얼 포트 통신 (디버깅용)
- [`pic8259`](https://crates.io/crates/pic8259): PIC 인터럽트 컨트롤러 제어
- [`acpi`](https://crates.io/crates/acpi): ACPI 테이블 파싱
- [`multiboot2`](https://crates.io/crates/multiboot2): Multiboot2 부트 프로토콜 지원
- [`uefi-rs`](https://crates.io/crates/uefi): UEFI 부팅 지원
- [`raw-cpuid`](https://crates.io/crates/raw-cpuid): CPU 기능 감지
- [`bitflags`](https://crates.io/crates/bitflags): 비트 플래그 타입 정의
- [`lazy_static`](https://crates.io/crates/lazy_static): 지연 초기화 정적 변수
- [`x86`](https://crates.io/crates/x86): x86 인스트럭션 래퍼
- [`gdbstub`](https://crates.io/crates/gdbstub): GDB 원격 디버깅 지원

## 학습 체크 리스트

### 부팅 프로세스 이해

- [ ] BIOS/UEFI 부팅 프로세스 이해
- [ ] 부트로더의 역할과 동작 방식
- [ ] 멀티부트 프로토콜 이해
- [ ] 커널 진입점과 초기화 순서
- [ ] 부팅 파라미터 전달 메커니즘

### 메모리 관리 구현

- [ ] 물리 메모리와 가상 메모리 개념
- [ ] 페이지 테이블 구조 이해
- [ ] 페이지 프레임 할당 알고리즘
  - [ ] 비트맵 기반 할당자
  - [ ] 버디 시스템 할당자
- [ ] 힙 할당자 구현
  - [ ] 연결 리스트 기반 할당자
  - [ ] 슬랩 할당자
- [ ] 가상 메모리 매핑
  - [ ] 페이지 테이블 생성 및 수정
  - [ ] TLB 무효화
- [ ] 메모리 보호
  - [ ] 페이지 권한 설정 (읽기/쓰기/실행)
  - [ ] 사용자/커널 공간 분리

### 인터럽트 처리

- [ ] 인터럽트와 예외의 차이
- [ ] IDT (Interrupt Descriptor Table) 구조
- [ ] 예외 핸들러 구현
  - [ ] 페이지 폴트 처리
  - [ ] 일반 보호 오류 처리
  - [ ] 더블 폴트 처리
- [ ] 하드웨어 인터럽트 처리
  - [ ] PIC 설정 및 초기화
  - [ ] 인터럽트 마스킹
  - [ ] 인터럽트 핸들러 등록
- [ ] 타이머 인터럽트
  - [ ] PIT (Programmable Interval Timer) 설정
  - [ ] 스케줄러 틱 생성

### 프로세스 관리

- [ ] 프로세스와 스레드 개념
- [ ] 프로세스 제어 블록 (PCB) 설계
- [ ] 컨텍스트 스위칭 구현
  - [ ] 레지스터 저장/복원
  - [ ] 스택 전환
- [ ] 스케줄링 알고리즘
  - [ ] Round Robin
  - [ ] Priority Scheduling
  - [ ] Multi-level Queue
- [ ] 프로세스 상태 관리
  - [ ] Ready, Running, Blocked 상태
  - [ ] 상태 전이 처리

### 파일 시스템

- [ ] 파일 시스템 기본 개념
- [ ] 블록 디바이스 인터페이스
- [ ] 간단한 파일 시스템 구현
  - [ ] 슈퍼블록 관리
  - [ ] inode 구조
  - [ ] 데이터 블록 할당
- [ ] 파일 시스템 드라이버 인터페이스
- [ ] VFS (Virtual File System) 레이어
- [ ] 파일 읽기/쓰기 연산
- [ ] 디렉토리 관리

### 디바이스 드라이버

- [ ] 드라이버 아키텍처 설계
- [ ] 디바이스 등록 및 관리
- [ ] 키보드 드라이버
  - [ ] PS/2 키보드 인터페이스
  - [ ] 키 입력 처리
- [ ] 마우스 드라이버
  - [ ] PS/2 마우스 인터페이스
  - [ ] 마우스 이벤트 처리
- [ ] 타이머 드라이버
  - [ ] 하드웨어 타이머 제어
  - [ ] 소프트웨어 타이머 구현
- [ ] 시리얼 포트 드라이버
  - [ ] UART 통신
  - [ ] 디버깅 출력

### 네트워크 스택

- [ ] 네트워크 계층 구조 이해
- [ ] 이더넷 드라이버 인터페이스
- [ ] 이더넷 프레임 처리
- [ ] ARP (Address Resolution Protocol) 구현
- [ ] IP 패킷 처리
  - [ ] IP 헤더 파싱
  - [ ] 라우팅 (기본)
- [ ] ICMP 프로토콜 구현
- [ ] UDP 프로토콜 구현 (기본)
- [ ] TCP 프로토콜 구현 (기본, 옵션)

### 보안 및 격리

- [ ] CPU 권한 레벨 (링 0, 1, 2, 3)
- [ ] 사용자 모드와 커널 모드 분리
- [ ] 시스템 콜 인터페이스
  - [ ] 시스템 콜 게이트
  - [ ] 권한 전환 처리
- [ ] 메모리 보호
  - [ ] 사용자 공간 격리
  - [ ] 커널 공간 보호
- [ ] 입력 검증 및 경계 검사

### 성능 최적화

- [ ] 캐시 친화적 데이터 구조
- [ ] 페이지 테이블 최적화
- [ ] 인터럽트 지연 최소화
- [ ] 컨텍스트 스위칭 오버헤드 감소
- [ ] 메모리 할당 최적화
- [ ] 락 경합 최소화

### 디버깅 및 테스트

- [ ] QEMU GDB 연동
  - [ ] 원격 디버깅 설정
  - [ ] 브레이크포인트 설정
  - [ ] 메모리/레지스터 검사
- [ ] 시리얼 포트 로깅
  - [ ] 로그 레벨 관리
  - [ ] 구조화된 로깅
- [ ] 커널 패닉 처리
  - [ ] 스택 트레이스 출력
  - [ ] 레지스터 덤프
  - [ ] 메모리 덤프
- [ ] 단위 테스트 전략
  - [ ] `no_std` 환경에서의 테스트
  - [ ] 모킹 및 테스트 더블

### 가상화 도구 활용

- [ ] QEMU 설정 및 실행
  - [ ] QEMU 설치 및 설정
    - [ ] Linux: `sudo apt install qemu-system-x86` (Ubuntu/Debian)
    - [ ] macOS: `brew install qemu`
    - [ ] Windows: QEMU 설치 프로그램 다운로드 또는 WSL2 활용
  - [ ] 커널 이미지 실행
    - [ ] 기본 실행: `qemu-system-x86_64 -kernel target/x86_64-bootloader/debug/bootimage-*.bin`
    - [ ] VGA 출력: `qemu-system-x86_64 -kernel <kernel> -serial stdio`
    - [ ] 그래픽 모드: `qemu-system-x86_64 -kernel <kernel> -display sdl`
  - [ ] 디버깅 모드 실행
    - [ ] GDB 서버 모드: `qemu-system-x86_64 -kernel <kernel> -s -S`
    - [ ] `-s`: GDB 서버를 1234 포트에서 시작
    - [ ] `-S`: 시작 시 CPU를 정지 상태로 유지
    - [ ] GDB 연결: `gdb -ex "target remote :1234"`
  - [ ] 네트워크 설정
    - [ ] 사용자 모드 네트워크: `qemu-system-x86_64 -kernel <kernel> -netdev user,id=net0 -device rtl8139,netdev=net0`
    - [ ] TAP 인터페이스 (고급): `-netdev tap,id=net0,ifname=tap0`
  - [ ] 디스크 이미지 마운트
    - [ ] 디스크 이미지 생성: `qemu-img create -f raw disk.img 64M`
    - [ ] 디스크 연결: `qemu-system-x86_64 -kernel <kernel> -drive file=disk.img,format=raw`
    - [ ] CD-ROM 이미지: `qemu-system-x86_64 -kernel <kernel> -cdrom image.iso`
  - [ ] 추가 유용한 옵션
    - [ ] 메모리 설정: `-m 512M` (512MB RAM)
    - [ ] CPU 설정: `-cpu qemu64` 또는 `-cpu host`
    - [ ] 부팅 순서: `-boot order=d` (디스크 우선)
    - [ ] 시리얼 포트: `-serial stdio` 또는 `-serial file:serial.log`
- [ ] Hyper-V 설정 및 실행 (Windows)
  - [ ] Hyper-V 활성화
    - [ ] PowerShell (관리자 권한): `Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All`
    - [ ] 또는 제어판 > 프로그램 > Windows 기능 켜기/끄기 > Hyper-V 체크
    - [ ] 재부팅 필요
  - [ ] 가상 머신 생성
    - [ ] Hyper-V 관리자 실행
    - [ ] 새로 만들기 > 가상 머신
    - [ ] 이름: "RustOS" 등
    - [ ] 세대: 1세대 (레거시 부팅 지원)
    - [ ] 메모리: 512MB 이상 할당
    - [ ] 네트워크: 기본 스위치 선택
    - [ ] 가상 하드 디스크: 기존 VHDX 선택 또는 새로 생성
  - [ ] 커널 이미지 부팅
    - [ ] 가상 머신 설정 > 펌웨어 > 부팅 순서에서 "DVD 드라이브" 우선 설정
    - [ ] ISO 이미지 생성: `bootimage` 크레이트 사용 또는 수동 생성
    - [ ] ISO 마운트: 가상 머신 설정 > DVD 드라이브 > ISO 파일 선택
    - [ ] 또는 VHDX에 커널 이미지 복사 후 부팅
  - [ ] 직렬 포트 설정
    - [ ] 가상 머신 설정 > COM 포트 추가
    - [ ] 명명된 파이프 사용: `\\.\pipe\RustOS`
    - [ ] Putty 또는 다른 시리얼 터미널로 연결
    - [ ] 또는 PowerShell: `Enter-PSSession -VMName RustOS`
  - [ ] 디버깅 설정
    - [ ] COM 포트를 통해 시리얼 디버깅 가능
    - [ ] 또는 네트워크 디버깅 (고급)
- [ ] 디버깅 환경 구축
  - [ ] GDB 설정
    - [ ] GDB 설치 확인: `gdb --version`
    - [ ] 크로스 디버거 필요 시: `rustup component add rust-src`
    - [ ] `.gdbinit` 파일 설정 (선택사항)
  - [ ] 원격 디버깅 연결
    - [ ] QEMU 디버깅 모드 시작: `qemu-system-x86_64 -kernel <kernel> -s -S`
    - [ ] 별도 터미널에서 GDB 실행: `gdb`
    - [ ] 심볼 파일 로드: `file target/x86_64-bootloader/debug/bootimage-*.bin`
    - [ ] 원격 연결: `target remote :1234`
    - [ ] 브레이크포인트 설정: `break kernel_main`
    - [ ] 실행: `continue` 또는 `c`
  - [ ] 디버그 심볼 로드
    - [ ] Cargo.toml에 디버그 정보 포함 확인: `[profile.dev] debug = true`
    - [ ] 심볼 파일 경로 확인: `readelf -w <kernel> | grep debug_info`
    - [ ] GDB에서 심볼 로드: `symbol-file <kernel>`
  - [ ] 유용한 GDB 명령어
    - [ ] 레지스터 확인: `info registers`
    - [ ] 스택 트레이스: `bt` 또는 `backtrace`
    - [ ] 메모리 덤프: `x/16x $rsp` (스택 포인터 주변 메모리)
    - [ ] 변수 값 확인: `print variable_name`
    - [ ] 단계 실행: `step` (s) 또는 `next` (n)
    - [ ] 어셈블리 코드 보기: `disassemble`

### 빌드 시스템 및 도구

- [ ] 크로스 컴파일 툴체인 설정
  - [ ] `rustup target add`
  - [ ] 커스텀 타겟 정의
- [ ] 링커 스크립트 작성
  - [ ] 메모리 레이아웃 정의
  - [ ] 섹션 배치
  - [ ] 심볼 정의
- [ ] 빌드 스크립트 (`build.rs`)
  - [ ] 링커 스크립트 포함
  - [ ] 조건부 컴파일
- [ ] Cargo 설정 최적화
  - [ ] 릴리즈 빌드 최적화
  - [ ] 디버그 정보 관리

### 문서화 및 커뮤니티

- [ ] 코드 문서화 (`rustdoc`)
- [ ] 아키텍처 문서 작성
- [ ] API 문서 생성
- [ ] 튜토리얼 및 가이드 작성
- [ ] 오픈소스 기여 방법